#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import pylab as plt
import os
from astropy.io import fits
from astropy.coordinates import SkyCoord
import astropy.units as u
from photutils import CircularAperture,SkyEllipticalAperture,aperture_photometry,EllipticalAnnulus
from photutils.utils import calc_total_error
from astropy.coordinates import SkyCoord
from astropy.stats import sigma_clipped_stats
from astropy import wcs
import glob
import cosmo
import math
import matplotlib.pyplot as plt
import re


# In[2]:


#creating a list with all supernovae filenames
supernovae = os.listdir('/Users/hsolak/PS_validation/DES-SN3YR/DES-SN3YR_DES')
supernovae.remove('DES-SN3YR_DES.IGNORE')
supernovae.remove('DES-SN3YR_DES.LIST')
supernovae.remove('DES-SN3YR_DES.README')
for i in range(len(supernovae)):
    supernovae[i] = supernovae[i].lstrip('.')
    supernovae[i] = supernovae[i].strip('.swp')


# In[3]:


#creating 2 dimensional arrays for measurements in each filter - first entry of row is DES, second is PANSTARRS
g = []
r = []
i = []

for j in range(len(supernovae)):
    g.append([])
    for k in range(3):
        g[j].append(0)
        
for j in range(len(supernovae)):
    r.append([])
    for k in range(3):
        r[j].append(0)
        
for j in range(len(supernovae)):
    i.append([])
    for k in range(3):
        i[j].append(0)


# In[4]:


apr_arcsec = 1 #(~1 FWHM)
# arcsec to number of PS1 pixels (0.25 arcsec/pix)
apr_pix = apr_arcsec/0.25

## routine for doing the aperture photometry
## note that no sky subtraction is done because PS1 images should already be sky-subtracted
def doAperPhot(xpos,ypos,image,exptime,zpt,aprad,errorim=[],unit='counts/sec'):

    if type(xpos) == np.ndarray:
        positions = [(x,y) for x,y in zip(xpos,ypos)]
    else:
        positions = [(xpos,ypos)]

    if not len(errorim):
        # get the uncertainty from the sky standard deviation, sigma-clipped STD
        avg,sky,skystd = sigma_clipped_stats(
            image[(image != 0)],
            sigma=3.0)

    ap = CircularAperture(positions,r=aprad)

    # this is a big weird, but part of checking if aperture extends beyond image
    apermask = ap.to_mask(method='exact')[0]
    imshape = np.shape(image)
    apermask_full = apermask.to_image(imshape)
    apermask_cols = np.where(apermask_full > 0)
    if apermask.bbox.ixmin < 0 or apermask.bbox.iymin < 0 or        apermask.bbox.ixmax > imshape[1]-1 or apermask.bbox.iymax > imshape[0]-1:
        print('Error : aperture extends outside the image!!')
        if type(xpos) == np.ndarray:
            return(np.array([np.nan]*len(xpos)),np.array([np.nan]*len(xpos)),np.array([np.nan]*len(xpos)),
                   np.array([np.nan]*len(xpos)),np.array([1]*len(xpos)))
        else:
            return(np.nan,np.nan,np.nan,np.nan,1)
    try:
        apOutsideImageCols = np.where((apermask_cols[0] == 0) | (apermask_cols[1] == 0) |
                                      (apermask_cols[0] == imshape[0]-1) | (apermask_cols[1] == imshape[1]-1))[0]
    except:
        import pdb; pdb.set_trace()

    # check if aperture extends outside the image
    if len(apOutsideImageCols):
        print('Error : aperture extends outside the image!!')
        if type(xpos) == np.ndarray:
            return(np.array([np.nan]*len(xpos)),np.array([np.nan]*len(xpos)),
                   np.array([sky]*len(xpos)),np.array([np.nan]*len(xpos)),np.array([1]*len(xpos)))
        else:
            return(np.nan,np.nan,sky,np.nan,1)

    if len(errorim):
        phot_table = aperture_photometry(image, ap, error=errorim)
    else:
        # calc error from sky standard deviation and image data (poisson noise & sky std)
        if unit == 'counts/sec':
            err = calc_total_error(image, skystd, exptime)
        else:
            err = calc_total_error(image, skystd, 1.0)
        phot_table = aperture_photometry(image, ap, error=err)

    if type(xpos) == np.ndarray:
        flux = phot_table['aperture_sum']	
        fluxerr = phot_table['aperture_sum_err']#**2.#+ skystd**2./ellap.area() )
    else:
        flux = phot_table['aperture_sum'][0]	
        fluxerr = phot_table['aperture_sum_err'][0]#**2.#+ skystd**2./ellap.area() )

    mag = -2.5*np.log10(flux) + zpt
    magerr = 2.5/np.log(10)*fluxerr/flux

    return(mag,magerr,flux,fluxerr,0)


# In[5]:


#Populate the lists
for k in range(len(supernovae)):
    sn_file = open('/Users/hsolak/PS_validation/DES-SN3YR/DES-SN3YR_DES/' + supernovae[k])
    
    sn_lst = []
    
    for line in sn_file:
        line = line
        sn_lst.append(line)
    
    #get DES measurement fluxcal
    flux_vals = re.findall(r"[-+]?\d*\.\d+|\d+", sn_lst[22])
    g[k][0] = float(flux_vals[0])
    r[k][0] = float(flux_vals[1])
    i[k][0] = float(flux_vals[2])
    
    #get info for PANSTARRS measurement
    temp_id = supernovae[k].strip('des_0')
    
    snid = temp_id.strip('.dat')
    ra = float(re.findall(r"[-+]?\d*\.\d+|\d+", sn_lst[7])[0])
    dec = float(re.findall(r"[-+]?\d*\.\d+|\d+", sn_lst[8])[0])
    
    if dec < -30:
        continue
        
    if snid == '1317277':
        continue
    
    #David's code
    if not os.path.exists('ps1_images/%s'%snid):
        os.makedirs('ps1_images/%s'%snid)
    
    files = glob.glob('ps1_images/%s/*fits'%snid)
    
    while len(files) == 0:
    
        # fits files, 60 arcmin width,custom download folder
        if not len(glob.glob('ps1_images/%s/*fits'%snid)) > 0:
            panstamps_cmd = "panstamps -f --width 60 --downloadFolder ps1_images/%s stack %.7f %.7f"%(snid,ra,dec)
            print("running '%s'"%panstamps_cmd)
            os.system(panstamps_cmd)
            
        files = glob.glob('ps1_images/%s/*fits'%snid)
        
    ## grab the images, figure out where in each image the SN position is in each
    #files = glob.glob('ps1_images/%s/*fits'%snid)

    # for each image, get obs filter and image coordinates for the SN
    filters,xpos,ypos = [],[],[]
    for f in files:
        print(f)
        filters += [fits.getval(f,'FPA.FILTER').split('.')[0]]
        ps1_wcs = wcs.WCS(fits.getheader(f))
        snx,sny = ps1_wcs.wcs_world2pix([(ra,dec)],0)[0]
        xpos += [snx]; ypos += [sny]
    
    for f,x,y,flt in zip(files,xpos,ypos,filters):
        image = fits.getdata(f)
        header = fits.getheader(f)
        ps1_zpt = 25.+2.5*np.log10(float(header['EXPTIME']))
        zpt = 10**(-0.4*(ps1_zpt-27.5))
        #print('ps1-zpt',ps1_zpt)
        #print(zpt)
        # PS1 zeropoints are set to 25 + 2.5*log10(exptime)
        mag,magerr,flux,fluxerr,badflag =             doAperPhot(x,y,image,header['EXPTIME'],25.+2.5*np.log10(float(header['EXPTIME'])),
                       apr_pix,unit='counts')
        # wikipedia says surface brightness is mag + 2.5*np.log10(area)
        sb = mag + 2.5*np.log10(np.pi*apr_arcsec**2.)
        flux = flux * zpt / math.pi
        fluxerr = fluxerr * zpt / math.pi
        
        if flt == 'g':
            g[k][1] = flux
            g[k][2] = fluxerr
        if flt == 'r':
            r[k][1] = flux
            r[k][2] = fluxerr
        if flt == 'i':
            i[k][1] = flux
            i[k][2] = fluxerr
            
print('g comparisons DES/David: ',g)
print()
DES = []
David = []
for j in range(len(g)):
    DES.append(g[j][0])
    David.append(g[j][1])
plt.scatter(DES,David)
print()
print()

print('r comparisons DES/David: ',r)
print()
DES = []
David = []
for j in range(len(r)):
    DES.append(r[j][0])
    David.append(r[j][1])
plt.scatter(DES,David)
print()
print()

print('i comparisons DES/David: ',i)
print()
DES = []
David = []
for j in range(len(i)):
    DES.append(i[j][0])
    David.append(i[j][1])
plt.scatter(DES,David)
print()
print()

